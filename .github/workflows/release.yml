# Build and deploy cloud service to production
# Triggered when a version tag (cloud-v*) is pushed
name: "Release: Deploy to Production"

on:
  push:
    tags:
      - "cloud-v*" # e.g., cloud-v0.2.0
  workflow_dispatch:
    inputs:
      version:
        description: "Version tag (e.g., cloud-v0.2.0)"
        required: true

concurrency:
  group: release-cloud
  cancel-in-progress: false

permissions:
  contents: read
  actions: read

jobs:
  wait-for-app:
    name: Wait for App Build
    runs-on: ubuntu-latest
    outputs:
      app-version: ${{ steps.version.outputs.version }}
      app-version-num: ${{ steps.version.outputs.version_num }}
    steps:
      - name: Get Version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${GITHUB_REF#refs/tags/}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          VERSION_NUM="${VERSION#cloud-v}"
          echo "version_num=$VERSION_NUM" >> $GITHUB_OUTPUT
          APP_VERSION="app-v${VERSION_NUM}"
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT

      - name: Get App Commit SHA and Wait for Workflow
        id: wait-for-app
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const tag = '${{ steps.version.outputs.app_version }}';
            const checkName = 'Build App';
            const maxWaitTime = 30 * 60 * 1000; // 30 minutes
            const pollInterval = 10 * 1000; // 10 seconds
            const startTime = Date.now();

            console.log(`Looking for tag: ${tag} in brewos-io/app`);

            // Get the commit SHA for the tag (with retry in case tag is being created)
            let commitSha;
            const tagWaitTime = 5 * 60 * 1000; // 5 minutes to wait for tag
            const tagPollInterval = 5 * 1000; // 5 seconds
            const tagStartTime = Date.now();
            let tagFound = false;

            while (!tagFound && (Date.now() - tagStartTime) < tagWaitTime) {
              try {
                const { data: ref } = await github.rest.git.getRef({
                  owner: 'brewos-io',
                  repo: 'app',
                  ref: `tags/${tag}`
                });
                commitSha = ref.object.sha;
                console.log(`✓ Tag ${tag} found! Points to commit: ${commitSha}`);
                tagFound = true;
              } catch (error) {
                if (error.status === 404) {
                  const elapsed = Math.floor((Date.now() - tagStartTime) / 1000);
                  console.log(`Tag ${tag} not found yet, waiting... (${elapsed}s elapsed)`);
                  await new Promise(resolve => setTimeout(resolve, tagPollInterval));
                } else {
                  throw new Error(`Error checking for tag ${tag} in brewos-io/app: ${error.message}`);
                }
              }
            }

            if (!tagFound) {
              throw new Error(
                `Tag ${tag} not found in brewos-io/app after ${tagWaitTime/1000/60} minutes. ` +
                `Please ensure the app tag is created before deploying cloud. ` +
                `Expected tag format: app-v${tag.replace('app-v', '')}`
              );
            }

            core.setOutput('commit_sha', commitSha);

            // Find workflow runs for this commit
            console.log(`Looking for workflow runs for commit ${commitSha} (tag: ${tag})...`);
            let workflowRun = null;

            // Search by commit SHA
            console.log(`Searching for workflow runs by commit SHA...`);
            const { data: runsBySha } = await github.rest.actions.listWorkflowRuns({
              owner: 'brewos-io',
              repo: 'app',
              workflow_id: 'release.yml',
              head_sha: commitSha,
              per_page: 50
            });
            console.log(`Found ${runsBySha.workflow_runs.length} run(s) by commit SHA`);

            // Search by tag ref (workflows triggered by tag push use the tag as head_branch)
            console.log(`Searching for workflow runs by tag ref...`);
            let runsByTag = { workflow_runs: [] };
            try {
              const { data } = await github.rest.actions.listWorkflowRuns({
                owner: 'brewos-io',
                repo: 'app',
                workflow_id: 'release.yml',
                ref: tag,
                per_page: 50
              });
              runsByTag = data;
              console.log(`Found ${runsByTag.workflow_runs.length} run(s) by tag ref`);
            } catch (error) {
              console.log(`Could not search by tag ref: ${error.message}`);
            }

            // Search recent workflow runs to catch any that might not be indexed yet
            console.log(`Searching recent workflow runs...`);
            const { data: recentRuns } = await github.rest.actions.listWorkflowRuns({
              owner: 'brewos-io',
              repo: 'app',
              workflow_id: 'release.yml',
              per_page: 200 // Increased to catch older runs
            });
            console.log(`Found ${recentRuns.workflow_runs.length} recent workflow run(s)`);

            // Combine and deduplicate runs - prioritize commit SHA matching
            const allRuns = [...runsBySha.workflow_runs];

            // Add runs from tag search, but only if they match the commit SHA
            // This prevents picking up runs from different versions with similar tag names
            runsByTag.workflow_runs.forEach(run => {
              if (!allRuns.find(r => r.id === run.id) && run.head_sha === commitSha) {
                allRuns.push(run);
                console.log(`Added run ${run.id} from tag search (matches commit SHA)`);
              } else if (run.head_sha !== commitSha) {
                console.log(`Skipping run ${run.id} from tag search (commit SHA mismatch: ${run.head_sha} != ${commitSha})`);
              }
            });

            // Add runs from recent search that match commit SHA
            recentRuns.workflow_runs.forEach(run => {
              if (!allRuns.find(r => r.id === run.id) && run.head_sha === commitSha) {
                allRuns.push(run);
              }
            });

            // Also check if any recent run matches the tag name AND commit SHA
            // Only add if commit SHA matches to avoid picking wrong version
            recentRuns.workflow_runs.forEach(run => {
              if (!allRuns.find(r => r.id === run.id) && run.head_sha === commitSha) {
                // Check if run was triggered by this tag (and matches commit)
                if (run.head_branch === tag || run.head_ref === tag || 
                    (run.head_branch && run.head_branch.includes(tag.replace('app-', '')))) {
                  allRuns.push(run);
                }
              }
            });

            console.log(`Total unique workflow run(s) found: ${allRuns.length}`);
            if (allRuns.length > 0) {
              console.log(`Run details:`);
              allRuns.forEach(run => {
                console.log(`  - Run ${run.id}: status=${run.status}, conclusion=${run.conclusion}, head_sha=${run.head_sha}, head_branch=${run.head_branch}, head_ref=${run.head_ref}`);
              });
            }

            // CRITICAL: Filter to only runs that match the commit SHA
            // This ensures we don't pick up runs from different tags/versions
            const matchingRuns = allRuns.filter(run => run.head_sha === commitSha);
            console.log(`Runs matching commit SHA ${commitSha}: ${matchingRuns.length}`);

            if (matchingRuns.length > 0) {
              // Prefer completed successful runs first (but only for the correct commit)
              const completedRun = matchingRuns.find(run => 
                run.status === 'completed' && run.conclusion === 'success'
              );
              
              if (completedRun) {
                workflowRun = completedRun;
                console.log(`✓ Found completed successful workflow run: ${workflowRun.id}`);
                console.log(`  Created: ${workflowRun.created_at}`);
                console.log(`  Completed: ${workflowRun.updated_at}`);
                console.log(`  Commit SHA: ${workflowRun.head_sha}`);
                core.setOutput('run_id', workflowRun.id);
                return; // Exit early, no need to wait
              }
              
              // Check for in-progress or queued runs (for the correct commit)
              const inProgressRun = matchingRuns.find(run => 
                run.status === 'in_progress' || run.status === 'queued'
              );
              
              if (inProgressRun) {
                workflowRun = inProgressRun;
                console.log(`Found in-progress workflow run: ${workflowRun.id} (status: ${workflowRun.status})`);
                console.log(`  Commit SHA: ${workflowRun.head_sha}`);
              } else {
                // Use most recent run matching the commit (might be failed, but we'll check)
                workflowRun = matchingRuns.sort((a, b) => 
                  new Date(b.created_at) - new Date(a.created_at)
                )[0];
                console.log(`Found workflow run: ${workflowRun.id} (status: ${workflowRun.status}, conclusion: ${workflowRun.conclusion})`);
                console.log(`  Commit SHA: ${workflowRun.head_sha}`);
                
                // If it's already completed but not successful, fail immediately
                if (workflowRun.status === 'completed' && workflowRun.conclusion !== 'success') {
                  throw new Error(`Workflow run ${workflowRun.id} completed with conclusion: ${workflowRun.conclusion}`);
                }
              }
            } else if (allRuns.length > 0) {
              // No runs match the commit SHA, but we found some runs
              // This might mean the tag points to a different commit than expected
              console.log(`⚠️ Warning: Found ${allRuns.length} workflow run(s) but none match commit SHA ${commitSha}`);
              console.log(`Available runs have these commit SHAs:`);
              allRuns.forEach(run => {
                console.log(`  - Run ${run.id}: ${run.head_sha} (${run.head_branch || 'unknown branch'})`);
              });
              // Don't use these runs - wait for the correct one to appear
              workflowRun = null;
            }

            // If no workflow run found at all, wait for it to start (tag might have just been pushed)
            if (!workflowRun) {
              console.log(`No workflow run found yet. Tag exists, so workflow should start soon...`);
              let attempts = 0;
              const maxInitialAttempts = 12; // Wait up to 2 minutes for workflow to start
              
              while (!workflowRun && attempts < maxInitialAttempts && (Date.now() - startTime) < maxWaitTime) {
                attempts++;
                const { data: newRuns } = await github.rest.actions.listWorkflowRuns({
                  owner: 'brewos-io',
                  repo: 'app',
                  workflow_id: 'release.yml',
                  head_sha: commitSha,
                  per_page: 10
                });
                
                if (newRuns.workflow_runs.length > 0) {
                  // Check for completed successful first
                  const completed = newRuns.workflow_runs.find(run => 
                    run.status === 'completed' && run.conclusion === 'success'
                  );
                  if (completed) {
                    workflowRun = completed;
                    console.log(`✓ Found completed workflow run: ${workflowRun.id}`);
                    core.setOutput('run_id', workflowRun.id);
                    return;
                  }
                  
                  workflowRun = newRuns.workflow_runs[0];
                  console.log(`Found workflow run: ${workflowRun.id} (status: ${workflowRun.status})`);
                  break;
                }
                
                console.log(`Attempt ${attempts}: No workflow run found yet, waiting ${pollInterval/1000}s...`);
                await new Promise(resolve => setTimeout(resolve, pollInterval));
              }
              
              // If still no workflow run after initial attempts, the tag might be old
              if (!workflowRun) {
                // Check tag creation time
                let tagDate;
                try {
                  const { data: tagInfo } = await github.rest.repos.getTag({
                    owner: 'brewos-io',
                    repo: 'app',
                    tag: tag
                  });
                  // Try different date fields
                  tagDate = new Date(tagInfo.tagger?.date || tagInfo.commit?.committer?.date || Date.now());
                } catch (error) {
                  tagDate = new Date();
                }
                
                const minutesSinceTag = (Date.now() - tagDate.getTime()) / (1000 * 60);
                console.log(`Tag age: ${minutesSinceTag.toFixed(1)} minutes`);
                
                if (minutesSinceTag > 10) {
                  // Tag is more than 10 minutes old, workflow should have run by now
                  throw new Error(
                    `No workflow run found for tag ${tag} (commit ${commitSha}). ` +
                    `Tag was created ${minutesSinceTag.toFixed(0)} minutes ago. ` +
                    `The app release workflow may not have been triggered. ` +
                    `Please check if the workflow exists and is configured to run on tag pushes.`
                  );
                }
                
                // Continue waiting if tag is recent
                console.log(`Tag is recent, continuing to wait for workflow to start...`);
                while (!workflowRun && (Date.now() - startTime) < maxWaitTime) {
                  attempts++;
                  const { data: newRuns } = await github.rest.actions.listWorkflowRuns({
                    owner: 'brewos-io',
                    repo: 'app',
                    workflow_id: 'release.yml',
                    head_sha: commitSha,
                    per_page: 10
                  });
                  
                  if (newRuns.workflow_runs.length > 0) {
                    workflowRun = newRuns.workflow_runs[0];
                    console.log(`Found workflow run: ${workflowRun.id} (status: ${workflowRun.status})`);
                    break;
                  }
                  
                  console.log(`Attempt ${attempts}: No workflow run found yet, waiting ${pollInterval/1000}s...`);
                  await new Promise(resolve => setTimeout(resolve, pollInterval));
                }
                
                if (!workflowRun) {
                  throw new Error(`No workflow run found for commit ${commitSha} after ${maxWaitTime/1000/60} minutes`);
                }
              }
            }

            // If workflow is already completed successfully, use it immediately
            if (workflowRun.status === 'completed' && workflowRun.conclusion === 'success') {
              console.log(`✓ Workflow run ${workflowRun.id} already completed successfully!`);
              core.setOutput('run_id', workflowRun.id);
              return; // Exit early, no need to wait
            }

            // Wait for the workflow to complete (only if it's still running)
            console.log(`Waiting for workflow run ${workflowRun.id} to complete...`);
            while (workflowRun.status !== 'completed' && (Date.now() - startTime) < maxWaitTime) {
              await new Promise(resolve => setTimeout(resolve, pollInterval));
              
              const { data: run } = await github.rest.actions.getWorkflowRun({
                owner: 'brewos-io',
                repo: 'app',
                run_id: workflowRun.id
              });
              
              workflowRun = run;
              console.log(`Status: ${workflowRun.status}${workflowRun.conclusion ? `, conclusion: ${workflowRun.conclusion}` : ''}`);
            }

            if (workflowRun.status !== 'completed') {
              throw new Error(`Workflow run ${workflowRun.id} did not complete within ${maxWaitTime/1000/60} minutes`);
            }

            if (workflowRun.conclusion !== 'success') {
              throw new Error(`Workflow run ${workflowRun.id} completed with conclusion: ${workflowRun.conclusion}`);
            }

            console.log(`✓ Workflow run ${workflowRun.id} completed successfully!`);
            core.setOutput('run_id', workflowRun.id);

      - name: Download App Artifact
        uses: dawidd6/action-download-artifact@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          workflow: release.yml
          workflow_conclusion: success
          run_id: ${{ steps.wait-for-app.outputs.run_id }}
          name: app-cloud-${{ steps.version.outputs.app_version }}
          path: app-build
          repo: brewos-io/app
          if_no_artifact_found: fail

      - name: Upload App Build for Deployment
        uses: actions/upload-artifact@v6
        with:
          name: app-build-for-deploy
          path: app-build/
          retention-days: 1

  deploy-production:
    needs: wait-for-app
    name: Deploy to Production
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://cloud.brewos.io
    steps:
      - name: Determine ref to checkout
        id: ref
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "ref=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "ref=${{ github.ref }}" >> $GITHUB_OUTPUT
          fi

      - name: Get Version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${GITHUB_REF#refs/tags/}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          VERSION_NUM="${VERSION#cloud-v}"
          echo "version_num=$VERSION_NUM" >> $GITHUB_OUTPUT

      - name: Download App Build Artifact
        uses: actions/download-artifact@v6
        with:
          name: app-build-for-deploy
          path: app-build

      - name: Upload App Build to Server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_SSH_HOST || 'cloud.brewos.io' }}
          username: root
          key: ${{ secrets.SERVER_SSH_KEY }}
          source: "app-build/*"
          target: "/tmp/app-build"
          strip_components: 0

      - name: Deploy to production server
        uses: appleboy/ssh-action@v1.2.4
        env:
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          RELEASE_VERSION: ${{ steps.version.outputs.version }}
        with:
          host: ${{ secrets.SERVER_SSH_HOST || 'cloud.brewos.io' }}
          username: root
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: GOOGLE_CLIENT_ID,RELEASE_VERSION
          command_timeout: 15m
          script: |
            set -e

            # Clone repository if it doesn't exist
            if [ ! -d "/root/brewos-cloud" ]; then
              echo "Cloning cloud repository..."
              git clone https://github.com/brewos-io/cloud.git /root/brewos-cloud
            fi

            cd /root/brewos-cloud

            # Clean up any local changes
            git reset --hard
            git clean -fd

            # Fetch the release tag
            git fetch origin --tags --force
            git checkout ${RELEASE_VERSION}

# Copy pre-built app from uploaded artifact
rm -rf web
mkdir -p web
# Handle case where SCP creates nested directory structure
if [ -d "/tmp/app-build/app-build" ]; then
  # Files are nested in app-build/app-build
  cp -r /tmp/app-build/app-build/* web/
elif [ -d "/tmp/app-build" ]; then
  # Files are directly in app-build
  cp -r /tmp/app-build/* web/
else
  echo "ERROR: /tmp/app-build not found!"
  exit 1
fi
rm -rf /tmp/app-build

            # Create .env for cloud service
            cat > .env << EOF
            GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
            PORT=3001
            DATA_DIR=/data
            TRUST_PROXY=true
            APP_DIST_PATH=/app/web
            EOF

            # Update docker-compose.yml for production deployment
            # The app files are copied into the Docker image at /app/web during build
            # So we should NOT mount ../web/dist:/app/web (that's the marketing site)
            # and we should set APP_DIST_PATH=/app/web to use files from the image
            if [ -f "docker-compose.yml" ]; then
              # Remove the volume mount for /app/web since files are in the image
              sed -i '/- \.\.\/web\/dist:\/app\/web:ro/d' docker-compose.yml
              
              # Remove the volume mount for /app/app/dist since we're using /app/web from image
              sed -i '/- \.\.\/app\/dist:\/app\/app\/dist:ro/d' docker-compose.yml
              
              # Add APP_DIST_PATH to environment section if not already present
              if ! grep -q "APP_DIST_PATH" docker-compose.yml; then
                # Insert APP_DIST_PATH after WEB_DIST_PATH line
                sed -i '/WEB_DIST_PATH/a\      - APP_DIST_PATH=/app/web' docker-compose.yml
              else
                # Update existing APP_DIST_PATH line
                sed -i 's|APP_DIST_PATH=.*|APP_DIST_PATH=/app/web|' docker-compose.yml
              fi
            fi

            # Build Admin UI
            cd admin
            npm ci
            npm run build
            cd ..

            # Get version from package.json for logging
            VERSION=$(node -p "require('./package.json').version")
            echo "Building cloud service version: $VERSION"

            # Build Docker image
            if [ -f "scripts/docker-build.sh" ]; then
              bash scripts/docker-build.sh
            else
              docker build -t brewos-cloud:latest .
            fi

            # Tag image with version
            docker tag brewos-cloud:latest brewos-cloud:$VERSION || true

            # Restart service
            docker compose down
            docker compose up -d

            # Wait for service to be healthy
            echo "Waiting for service to start..."
            sleep 5

            for i in 1 2 3 4 5; do
              if curl -sf http://localhost:3001/api/health > /dev/null; then
                echo "✓ Production service is healthy!"
                echo "  Deployed version: ${RELEASE_VERSION}"
                docker system prune -af --filter "until=1h" || true
                exit 0
              fi
              echo "Waiting... ($i/5)"
              sleep 3
            done

            echo "✗ Health check failed!"
            docker compose logs --tail=50
            exit 1
